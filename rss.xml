<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[我的博客]]></title><description><![CDATA[用于记录一些开发过程中的小坑和大坑]]></description><link>https://hades-li.github.io/blog</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 18 Feb 2020 09:00:11 GMT</lastBuildDate><item><title><![CDATA[浅谈typescript用于vue开发的优点和坑]]></title><description><![CDATA[typescript的两个核心,面向对象和强类型 typescript目前主要应用的方向 web：angular,react,vue? 游戏：白鹭引擎,LayaAir引擎 typescript用于vue开发是否合适 有点鸡肋，但可以使项目变得更健壮，也可以使你变得更强。 原因…]]></description><link>https://hades-li.github.io/blog/typescript-vue/</link><guid isPermaLink="false">https://hades-li.github.io/blog/typescript-vue/</guid><pubDate>Sat, 26 Oct 2019 23:03:03 GMT</pubDate><content:encoded>&lt;h2&gt;typescript的两个核心,面向对象和强类型&lt;/h2&gt;
&lt;p&gt;typescript目前主要应用的方向&lt;/p&gt;
&lt;p&gt;web：angular,react,vue?&lt;/p&gt;
&lt;p&gt;游戏：白鹭引擎,LayaAir引擎&lt;/p&gt;
&lt;h2&gt;typescript用于vue开发是否合适&lt;/h2&gt;
&lt;p&gt;有点鸡肋，但可以使项目变得更健壮，也可以使你变得更强。&lt;/p&gt;
&lt;h3&gt;原因1：由于vue本身用自己的一套格式为.vue文件做了一个面向对象的封装，因此，typescript的面向对象特性并没有发挥其优势，仅仅是改变了一个形态。&lt;/h3&gt;
&lt;p&gt;typescript代码&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import { Component, Vue } from &amp;#39;vue-property-decorator&amp;#39;

@Component({
  name: &amp;#39;Page404&amp;#39;
})
export default class home extends Vue {
  private message = &amp;#39;home&amp;#39;
  get name() {
    return this.$route.query.name 
  }
  created() {

  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;js代码&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;export default {
  name: &amp;#39;Page404&amp;#39;,
  data: {
    return {
        message = &amp;#39;home&amp;#39;
    }
  },
  computed: {
    name() {
        return this.$route.query.name 
    }
  },
  created() {
      
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上的一段简单代码，可以看出，js代码中data对象和computed的对像属性被变形成为了class中的成员函数和成员变量。这样的改变，为此你需要引入typescript中的一个重要第三方库vue-property-decorator，没有这个第三方库，你就不能以class的形式来写vue。而两者仅仅是形态上发生了一些变化，而开发上并没有产生什么新的思路和便利。&lt;/p&gt;
&lt;h3&gt;原因2：由于typescript是强类型语言，类型定义的工作量增加了。你再也不能无脑使用对象了。&lt;/h3&gt;
&lt;p&gt;typescript代码&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 类型申明
declare interface Person {
    name: string
    id: number
}

function show(person: Person) {
   console.log(`姓名:${person.name} 工号:${person.id}`)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;js代码&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function show(person) {
   console.log(`姓名:${person.name} 工号:${person.id}`)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;js代码看上去会更简洁。只要你心里面知道有person对象有name和id两个参数，你就可以进行打印输出。但ts的编译器会进行类型检查，如果你没有申明Person这个接口对象，那么程序将会在编译阶段报错。（当然对于anyscript大神，这些都不是问题。）&lt;/p&gt;
&lt;h2&gt;ts在vue中开发的优点&lt;/h2&gt;
&lt;h3&gt;优点1：同样强类型使得你的代码增加的同时，但也使得程序变得更加健壮。当你给一个变量传值时，你可以很清楚的知道传string还是number，并且IDE工具可以更好进行代码提示。&lt;/h3&gt;
&lt;h3&gt;优点2：vuex-module-decorators&lt;/h3&gt;
&lt;p&gt;这是一个让你的状态管理store调用起来很爽的第三方库，也是我认为在ts下开发vue感到便捷的东西。&lt;/p&gt;
&lt;p&gt;store初始化&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;interface StoreType {
  mm: MyModule
}
// Declare empty store first
const store = new Vuex.Store&amp;lt;StoreType&amp;gt;({})

@Module({ dynamic: true, store: store, name: &amp;#39;mm&amp;#39; })
class MyModule extends VuexModule {
  count = 0 // state

  @Mutation
  incrCount(delta) { // mutation
    this.count += delta
  }
  @Action
  add(delta) { // action
    this.incrCount(1)
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;store的调用&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;import { Component, Vue } from &amp;#39;vue-property-decorator&amp;#39;;
import { getModule } from &amp;#39;vuex-module-decorators&amp;#39;;
import MyModule from &amp;#39;~/store/modules/myModule&amp;#39;

@Component
export default class extends Vue {
    public created() {
        const MyModule = getModule(MyStoreModule);
        console.log(&amp;#39;count:&amp;#39; + MyModule.count) // 打印myModule的变量值
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化时，module的定义和js时变化较大，说白了，也是同样将module定义成了一个class。action, mutation, state这些对象全都变成了class中的成员函数和变量。&lt;/p&gt;
&lt;p&gt;但调用store时变的无比简单，getModule可以直接把store中的module作为对象取出来，然后你就可以直接访问module中的state和action函数等。比起原来的写法中要写大量的map是不是爽了很多。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[一个前端学习IOS开发采坑记-swift的闭包]]></title><description><![CDATA[前言 闭包在swift开发中非常常见。但它却和js中所谓的闭包并不相同。 它并不像javascript中的闭包 js中的闭包通常是用于将函数中的私有变量能够供函数外调用的函数，通常称作为闭包。在日常开发中，可以用于创建对象实例等。 但swift中的闭包和js…]]></description><link>https://hades-li.github.io/blog/swift-closure/</link><guid isPermaLink="false">https://hades-li.github.io/blog/swift-closure/</guid><pubDate>Wed, 16 Jan 2019 22:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;闭包在swift开发中非常常见。但它却和js中所谓的闭包并不相同。&lt;/p&gt;
&lt;h2&gt;它并不像javascript中的闭包&lt;/h2&gt;
&lt;p&gt;js中的闭包通常是用于将函数中的私有变量能够供函数外调用的函数，通常称作为闭包。在日常开发中，可以用于创建对象实例等。&lt;/p&gt;
&lt;p&gt;但swift中的闭包和js中的闭包几乎没有关系，它其实是从oc中的block衍生过来的产物，只是换了个名字叫闭包（closure）。首先来看一个典型的闭包。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;outText(callback: { (text: String) in
    let a = text
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;作为一个前端在看到这个代码后，肯定会说，这特么不就是一个回调函数嘛。确实，这就是一个回调函数，相当于如下的js代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;outText((text) =&amp;gt; {
    const a = text
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个函数功能完全一致，而函数中的回调函数，在swift中就被称为闭包。在swift中，闭包的主要工作之一就是用于作为回调函数来使用。&lt;/p&gt;
&lt;p&gt;除了作为回调函数外，另一个常用的功能就是用于实例化对象,代码如下&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;let objA = {
    let obj = View()
    return obj
}()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对，你没有看错，这特么就是js中的利用匿名函数创建对象，而那个匿名函数在swift中，就被称为是闭包的调用。相同的js如下表示：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const objA = function() {
    let obj = View()
    return obj
}()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;swift经常会通过这种方式来定义个控件。&lt;/p&gt;
&lt;h2&gt;闭包有多种简写的代码格式&lt;/h2&gt;
&lt;p&gt;对于前端开发者来说，swift的闭包在功能使用上并没有太多不同认知，你只需要知道它其实就是一个函数，用于回调和匿名函数即可。然而，swift的闭包变态的是它具有多种不同的格式写法，或者称作为多种简写。以下是一个完整写法和一个最简写法。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 完整写法
funcA(callback: { (a:Int,b:Int) -&amp;gt; Int
    return a + b
})
// 最简写
funcA{$0 + $1}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是不是有种三观被毁的感觉。这特么还是同一个东西吗？作为一个前端，我一开始看见这种简写形态是懵逼的。难道多写几个代码会死吗？&lt;/p&gt;
&lt;p&gt;不过，当你代码看多了的时候，你会发现很多别人的代码或者是一些开源库，在闭包的使用上几乎都是能用简写，绝对不用完整版。所以你只能习惯就好。其实我个人觉得完整版在阅读的时候更加清晰，参数使用更加明确。&lt;/p&gt;
&lt;p&gt;当然，完整版和最简写之间是有一连串的省略。以下就是各阶段省略的代码：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 完整写法
funcA(callback: { (a:Int,b:Int) -&amp;gt; Int in
    return a + b
})
// 省略闭包中参数的类型
funcA(callback: { (a,b) -&amp;gt; Int in
    return a + b
})
// 省略闭包中参数的挂号
funcA(callback: { a,b -&amp;gt; Int in
    return a + b
})
// 省略返回类型
funcA(callback: { a,b in
    return a + b
})
// 省略return 
funcA(callback:{a,b in 
    a+b
})
// 省略闭包中的参数
funcA(callback:{
    $0+$1
})
// 省略函数中的参数名
funcA({$0 + $1})
// 再把挂号去掉的最简写
funcA{$0 + $1}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上的简写，你可以根据需求使用任何一个阶段的简写。通常，也是在需求允许的情况做到最简单写法。&lt;/p&gt;
&lt;p&gt;在以上这些简写中的最后一步简写，涉及到一个闭包的新特性，叫做尾随闭包。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 完整写法
funcB(x1: Int, x2: Int, callback:{ (a: Int,b: Int) -&amp;gt; Int in
    return a + b
})

// 省略函数末尾的回调函数的参数，也就是闭包的名称
funcB(x1: Int, x2: Int){ (a: Int,b: Int) in
    return a + b
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上列子，并没有简写至最简写，目的是告诉你什么是尾随闭包。用前端小伙伴便于理解的话来说，就是如果这个回调函数被放在了函数参数的最后一个，那么我们就可以省略掉参数名称，并且把回调函数的大挂号放到函数外面来表示。&lt;/p&gt;
&lt;p&gt;就是由于这样的改变，可能会导致一个前端转过来的同学在阅读代码时看的会有点懵。但只要你知道它的完整版就很容易理解了。&lt;/p&gt;
&lt;p&gt;另外，闭包还有一个重要知识点，逃逸闭包。废话少说，看代码&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 定义一个带有闭包的函数
func a(callback: @escape (a:Int) -&amp;gt; Int) {
    // todo
    ...
    http.get(xxx).then{ data in
        callback(data)
    }
    ...
}

// 调用函数
a(callback: { a -&amp;gt; Int in
    return a + 1
}) &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和普通的闭包相比，仅仅在定义闭包的时候多了一个escape。它表示的意义是，当前这个闭包会在本身函数执行完毕后才执行。&lt;code class=&quot;language-text&quot;&gt;http.get()&lt;/code&gt;是表示这是一个请求函数或者是一个延时操作。只有当这个操作执行完成后才会执行闭包。而这样的闭包我们就必须加上escape来修饰。否则编译报错。&lt;/p&gt;
&lt;p&gt;用前端的理解就是，这个回调函数是由一个异步请求来触发的，我们就必须加上escape。这个特性在js里当然也是有的。只不过,js根本没有把回调分为异步回调和普通回调。无论哪种回调，写法都一样。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;ios开发，闭包随处可见。首先，不要被它的各种简写搞懵。其次，把他们当成回调函数，或者匿名函数理解就可以。如果是异步回调，就加上escape修饰。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[一个前端学习IOS开发采坑记-1]]></title><description><![CDATA[前言 这是用来记录我一个前端如何学习ios开发的经历，更多的是从一个前端的角度来理解ios开发。和一些框架思想的转变。 语言的选择 大多数人都很清楚，oc是ios开发的第一大语言。即便swift已经到了第4版。在目前的项目中，
依然是oc…]]></description><link>https://hades-li.github.io/blog/ios_1/</link><guid isPermaLink="false">https://hades-li.github.io/blog/ios_1/</guid><pubDate>Sat, 29 Dec 2018 14:12:03 GMT</pubDate><content:encoded>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;这是用来记录我一个前端如何学习ios开发的经历，更多的是从一个前端的角度来理解ios开发。和一些框架思想的转变。&lt;/p&gt;
&lt;h2&gt;语言的选择&lt;/h2&gt;
&lt;p&gt;大多数人都很清楚，oc是ios开发的第一大语言。即便swift已经到了第4版。在目前的项目中，
依然是oc为主力语言。其优点是非常完善的第三方框架库。
网上能找到各种各样的问题解决方案的样例都是基于oc的。这对于开发一个项目帮助非常大。
但如果那你用了swift，你会发现很多问题，你不得不去看人家是用oc怎么解决的，然后自己仿造用swift来实现。
自然开发效率就下降了。&lt;/p&gt;
&lt;p&gt;但是作为一个前端开发者，当你第一眼看到oc的语法时，你一定是懵逼的。当然，就连从事多年oc开发的
人来说，也是觉得oc的语法很变态。这也就是苹果为什么会创建swift语言的原因了。
作为前端来说，选择swift来作为开发ios语言，其学习难度要比oc小很多。因为它和js有很多相似的地方。
比如实例化一个对象：&lt;/p&gt;
&lt;p&gt;oc的：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;A *a = [A init]
NSString *str = [NSString stringWithFormat:@&amp;quot;字符串%d&amp;quot;,a]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;swift的:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var a = A()
var str:String = &amp;quot;hello world&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你是一个前端开发者，当你第一次看见oc的语法，估计可能会认为那在实例化一个数组。oc的特色就是各种”中挂号”。
很明显，swift语法更接近js。&lt;/p&gt;
&lt;p&gt;需要注意的是，swift是一门强类型的语言，而js是弱类型的。这是两者最大的区别。
不过，如果你是一个精通ts的前端，那么恭喜你，你掌握swift的时间又可以缩短了。
因为，两者不但都是强类型的语言，并且你会发现，两者在部分语法结构上几乎雷同。&lt;/p&gt;
&lt;p&gt;因此，我从能够快速上手的角度来判断。作为一个前端来说，选择swift作为基础语言是利大于弊的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目前，swift语言已经更新到第4版，已经不像前3版，每一次更新都能带来满屏红叉的效果。api基本已经稳定了。&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item></channel></rss>