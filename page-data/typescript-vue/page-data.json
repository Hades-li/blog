{"componentChunkName":"component---src-templates-blog-post-js","path":"/typescript-vue/","result":{"data":{"site":{"id":"Site","siteMetadata":{"title":"我的博客"}},"markdownRemark":{"id":"07d50189-d6df-52c4-ba76-166ecf6eea1f","excerpt":"typescript的两个核心,面向对象和强类型 typescript目前主要应用的方向 web：angular,react,vue? 游戏：白鹭引擎,LayaAir引擎 typescript用于vue开发是否合适 有点鸡肋，但可以使项目变得更健壮，也可以使你变得更强。 原因1：由于vue本身用自己的一套格式为.vue…","html":"<h2>typescript的两个核心,面向对象和强类型</h2>\n<p>typescript目前主要应用的方向</p>\n<p>web：angular,react,vue?</p>\n<p>游戏：白鹭引擎,LayaAir引擎</p>\n<h2>typescript用于vue开发是否合适</h2>\n<p>有点鸡肋，但可以使项目变得更健壮，也可以使你变得更强。</p>\n<h3>原因1：由于vue本身用自己的一套格式为.vue文件做了一个面向对象的封装，因此，typescript的面向对象特性并没有发挥其优势，仅仅是改变了一个形态。</h3>\n<p>typescript代码</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { Component, Vue } from &#39;vue-property-decorator&#39;\n\n@Component({\n  name: &#39;Page404&#39;\n})\nexport default class home extends Vue {\n  private message = &#39;home&#39;\n  get name() {\n    return this.$route.query.name \n  }\n  created() {\n\n  }\n}</code></pre></div>\n<p>js代码</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export default {\n  name: &#39;Page404&#39;,\n  data: {\n    return {\n        message = &#39;home&#39;\n    }\n  },\n  computed: {\n    name() {\n        return this.$route.query.name \n    }\n  },\n  created() {\n      \n  }\n}</code></pre></div>\n<p>以上的一段简单代码，可以看出，js代码中data对象和computed的对像属性被变形成为了class中的成员函数和成员变量。这样的改变，为此你需要引入typescript中的一个重要第三方库vue-property-decorator，没有这个第三方库，你就不能以class的形式来写vue。而两者仅仅是形态上发生了一些变化，而开发上并没有产生什么新的思路和便利。</p>\n<h3>原因2：由于typescript是强类型语言，类型定义的工作量增加了。你再也不能无脑使用对象了。</h3>\n<p>typescript代码</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 类型申明\ndeclare interface Person {\n    name: string\n    id: number\n}\n\nfunction show(person: Person) {\n   console.log(`姓名:${person.name} 工号:${person.id}`)\n}</code></pre></div>\n<p>js代码</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function show(person) {\n   console.log(`姓名:${person.name} 工号:${person.id}`)\n}</code></pre></div>\n<p>js代码看上去会更简洁。只要你心里面知道有person对象有name和id两个参数，你就可以进行打印输出。但ts的编译器会进行类型检查，如果你没有申明Person这个接口对象，那么程序将会在编译阶段报错。（当然对于anyscript大神，这些都不是问题。）</p>\n<h2>ts在vue中开发的优点</h2>\n<h3>优点1：同样强类型使得你的代码增加的同时，但也使得程序变得更加健壮。当你给一个变量传值时，你可以很清楚的知道传string还是number，并且IDE工具可以更好进行代码提示。</h3>\n<h3>优点2：vuex-module-decorators</h3>\n<p>这是一个让你的状态管理store调用起来很爽的第三方库，也是我认为在ts下开发vue感到便捷的东西。</p>\n<p>store初始化</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">interface StoreType {\n  mm: MyModule\n}\n// Declare empty store first\nconst store = new Vuex.Store&lt;StoreType&gt;({})\n\n@Module({ dynamic: true, store: store, name: &#39;mm&#39; })\nclass MyModule extends VuexModule {\n  count = 0 // state\n\n  @Mutation\n  incrCount(delta) { // mutation\n    this.count += delta\n  }\n  @Action\n  add(delta) { // action\n    this.incrCount(1)\n  }\n}</code></pre></div>\n<p>store的调用</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { Component, Vue } from &#39;vue-property-decorator&#39;;\nimport { getModule } from &#39;vuex-module-decorators&#39;;\nimport MyModule from &#39;~/store/modules/myModule&#39;\n\n@Component\nexport default class extends Vue {\n    public created() {\n        const MyModule = getModule(MyStoreModule);\n        console.log(&#39;count:&#39; + MyModule.count) // 打印myModule的变量值\n    }\n}</code></pre></div>\n<p>初始化时，module的定义和js时变化较大，说白了，也是同样将module定义成了一个class。action, mutation, state这些对象全都变成了class中的成员函数和变量。</p>\n<p>但调用store时变的无比简单，getModule可以直接把store中的module作为对象取出来，然后你就可以直接访问module中的state和action函数等。比起原来的写法中要写大量的map是不是爽了很多。</p>","frontmatter":{"title":"浅谈typescript用于vue开发的优点和坑","date":"2019-10-26","description":null}}},"pageContext":{"slug":"/typescript-vue/","previous":{"fields":{"slug":"/swift-closure/"},"frontmatter":{"title":"一个前端学习IOS开发采坑记-swift的闭包"}},"next":null}}}